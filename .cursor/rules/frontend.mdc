# Frontend Development Rules

Design-driven frontend development with consistent visual language and user experience.

## Design System Principles

**Visual Consistency**:
- Reuse global styles: Create and maintain a centralized style system
- Unified alignment and rhythm: Establish consistent spacing and layout patterns
- Clear information hierarchy: Use visual weight to guide user attention

**Typography Standards**:
- Font size hierarchy: Maximum 3 levels (e.g., heading, body, caption)
- Restrained font weight: Limit to 2-3 weights (e.g., regular, medium, bold)
- Comfortable line height: 1.5-1.6 for body text, 1.2-1.4 for headings
- Maintain readability across all screen sizes

**Color System**:
- Single primary color + neutral gray scale
- Low saturation: Prefer muted, professional tones
- Use color purposefully for hierarchy and emphasis
- Ensure sufficient contrast for accessibility (WCAG AA minimum)

**Spacing & Layout**:
- Consistent border radius: Define 2-3 radius values (e.g., 4px, 8px, 16px)
- Systematic spacing: Use multiples of base unit (e.g., 4px, 8px, 16px, 24px, 32px)
- Grid-based alignment: Maintain visual rhythm

**Empty States**:
- Always provide guidance: Clear message + actionable next steps
- Use illustrations or icons to enhance understanding
- Avoid bare "No data" messages

**Icons**:
- SVG format preferred: Scalable and performant
- Consistent stroke width and style
- Maintain icon size hierarchy (e.g., 16px, 20px, 24px)

## Code Quality Standards

**Component Structure**:
- Single responsibility: One component, one purpose
- Composition over inheritance: Build complex UIs from simple components
- Props validation: Use TypeScript or PropTypes
- Semantic HTML: Use appropriate tags for accessibility

**Style Management**:
- CSS-in-JS or CSS Modules: Avoid global namespace pollution
- Design tokens: Define colors, spacing, typography as constants
- Mobile-first responsive design
- Avoid inline styles except for dynamic values

**Performance**:
- Lazy load components and images
- Optimize bundle size: Code splitting, tree shaking
- Minimize re-renders: Use React.memo, useMemo, useCallback appropriately
- Debounce/throttle expensive operations

**Accessibility**:
- Keyboard navigation support
- ARIA labels for screen readers
- Focus management
- Color contrast compliance

**Animation & Transitions**:
- Disable animations for popups and dropdowns: No fade-in, zoom, or slide effects
- Instant display: Menus and overlays should appear immediately on interaction
- Exception: Subtle transitions for hover states (color, opacity) are acceptable
- Rationale: Improves perceived performance and reduces visual distraction

## Best Practices

**DO**:
- Extract magic numbers to design tokens
- Use consistent naming conventions (BEM, camelCase, etc.)
- Write self-documenting code with clear component names
- Test components in isolation (Storybook, unit tests)
- Document complex logic with comments

**DON'T**:
- Use arbitrary values: Always reference design tokens
- Create deeply nested components: Keep hierarchy flat
- Ignore edge cases: Handle loading, error, empty states
- Hardcode responsive breakpoints: Use shared constants
- Mix concerns: Separate business logic from presentation
- Add animations to dropdowns/popups: Avoid `animate-in`, `fade-in`, `zoom-in`, `slide-in` classes

## Key Differentiators

- **Design System First**: All UI decisions reference a centralized design system
- **Restrained Aesthetics**: Minimal color palette and typography hierarchy
- **User Guidance**: Every state (empty, error, loading) provides clear direction
- **Consistency**: Systematic approach to spacing, sizing, and visual rhythm
- **Scalability**: Token-based system allows easy theme updates
