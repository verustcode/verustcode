# LLM Client Integration Guide

Guide for integrating new LLM CLI clients (e.g., OpenAI CLI, etc.)

## Architecture

**Two-layer Design**: Agent Layer (Orchestration) → Client Layer (Execution) → External CLI

## Integration Process

### 1. Preliminary Research (Mandatory)

Confirm the following information:
- [ ] CLI command name and API Key environment variable name
- [ ] Headless parameters (`-p`, `--model`, `--output-format`)
- [ ] Output format (text, json, stream-json) and its schema
- [ ] Session management (creation, resumption, ID extraction)

### 2. File Structure

```
internal/llm/<name>/
  ├── <name>.go          # Client implementation
  └── <name>_test.go     # Tests

internal/agent/<name>/
  ├── <name>.go          # Agent implementation
  └── <name>_test.go     # Tests
```

### 3. Implement Client Layer

**Required Interfaces** (`internal/llm/client.go`):
- `Name()` - Returns the client identifier
- `Available()` - Detects if the CLI is available
- `GetConfig()` - Retrieves client configuration
- `Execute()` - Synchronous execution
- `Close()` - Resource cleanup

**Optional Interfaces**:
- `ExecuteStream()` - Streaming execution (if supported by CLI)
- `CreateSession()` - Session management (for multi-turn conversations)

**Core Logic**:
```go
// 1. Build arguments: []string{"-p", "--model", model, "--output-format", "text"}
// 2. Add session: --resume <session_id>
// 3. Create command: exec.CommandContext(ctx, cliPath, args...)
// 4. Set environment: cmd.Env + API Key
// 5. Write prompt to stdin (goroutine)
// 6. Wait for completion, handle timeouts and errors
// 7. Build response: BuildResponse()
```

### 4. Implement Agent Layer

**Responsibilities**: Create Client, manage configuration, call Client for execution.

Refer to `internal/agent/cursor/cursor.go` or `internal/agent/gemini/gemini.go`.

### 5. Registration and Configuration Check

**Important**: New Agents and Clients must be registered in multiple locations; otherwise, they won't be correctly loaded or validated.

#### 5.1 Agent Registration (`internal/agent/agents/agents.go`)
```go
import (
    // ... existing imports
    _ "github.com/verustcode/verustcode/internal/agent/<name>"  // Add new
)
```

#### 5.2 LLM Client Registration (`internal/check/validation.go`)
Used for validating agent availability during `serve --check`:
```go
import (
    // ... existing imports
    _ "github.com/verustcode/verustcode/internal/llm/<name>"  // Add new
)
```

Also, add the default CLI name in the `getDefaultCLIName()` function:
```go
case "<name>":
    return "<cli-command>"
```

#### 5.3 Credential Check (`internal/check/credentials.go`)
Used for checking API Key configuration during `serve --check`:

1. Add `CredentialType` constant:
```go
const (
    // ... existing constants
    Credential<Name> // <Name> CLI API key
)
```

2. Add configuration in `getCredentialConfigs()`:
```go
{
    Name:        "<Name> API Key",
    EnvVar:      "SC_<NAME>_API_KEY",
    ConfigPath:  "agents.<name>.api_key",
    Type:        Credential<Name>,
    Description: "<Name> API key",
    Required:    false,
},
```

3. Add handling in the `getConfigValue()` switch:
```go
case Credential<Name>:
    if agent := cfg.GetAgent("<name>"); agent != nil {
        return agent.APIKey
    }
```

> Note: `main.go` does not need modification as it automatically loads all agents via the `internal/agent/agents` aggregation package.

### 6. Configuration and Testing

**Configuration** (`config/config.example.yaml`):
```yaml
agents:
  <name>:
    cli_path: <cli-command>
    default_model: <model-name>
    timeout: 600
    api_key: ${<NAME>_API_KEY}
```

**Testing**: Verify registration, creation, and availability.

**Verification Checklist**:
- [ ] `go build` compiles successfully
- [ ] `go test` passes
- [ ] Client/Agent registration successful
- [ ] Added to `internal/agent/agents/agents.go` (Agent registration)
- [ ] Added to `internal/check/validation.go` (LLM Client registration + getDefaultCLIName)
- [ ] Added to `internal/check/credentials.go` (Credential check configuration)

## Key Technical Points

**Error Handling**:
- Timeout: `context.DeadlineExceeded` → `llm.ErrTimeout`
- Retryable: Network errors → `llm.NewRetryableError`

**API Key Masking**:
```go
func maskAPIKey(key string) string {
    if len(key) > 8 { return key[:4] + "..." + key[len(key)-4:] }
    return "***"
}
```

**Stream Parsing** (if supported):
- Read JSON line by line
- Categorize by `type` field (init/message/tool_use/result)
- Protect shared state with `sync.Mutex`

**Concurrency Safety**: Use goroutines for stdin writes and Mutex for shared variables.

## Best Practices

**DO ✅**
- Thoroughly research CLI parameters and formats
- Refer to `internal/llm/cursor/` and `internal/llm/gemini/`
- API Keys must be masked
- Use `BaseClient` utility methods
- Use goroutines for stdin writes

**DON'T ❌**
- Do not hardcode configurations
- Do not ignore errors
- Do not leak API Keys
- Do not block the main process

## References

**Reading Order**:
1. `internal/llm/cursor/cursor.go` - Full Client implementation
2. `internal/llm/gemini/gemini.go` - Streaming execution example
3. `internal/llm/qoder/qoder.go` - Simplified Client implementation
4. `internal/agent/cursor/cursor.go` - Agent implementation
5. `internal/agent/qoder/qoder.go` - Simplified Agent implementation


---
**Reference Document**: `docs/gemini_cli_integration.md`
