// Package config provides configuration management for the application.
// This file handles runtime settings stored in the database.
package config

import (
	"encoding/json"
	"fmt"
	"reflect"
	"strings"
	"sync"

	"go.uber.org/zap"
	"gorm.io/gorm"

	"github.com/verustcode/verustcode/internal/model"
	"github.com/verustcode/verustcode/internal/store"
	"github.com/verustcode/verustcode/pkg/logger"
)

// maskedPlaceholder is the placeholder used in masked values
const maskedPlaceholder = "****"

// defaultCustomText is the default value for review output metadata custom text
const defaultCustomText = "Generated by [VerustCode](https://github.com/verustcode/verustcode)"

// sensitiveKeyPatterns defines patterns for sensitive field names that should be masked
var sensitiveKeyPatterns = []string{
	"token",
	"api_key",
	"secret",
	"password",
	"private_key",
	"webhook_secret",
	"jwt_secret",
}

// isSensitiveKey checks if a key name indicates a sensitive field
func isSensitiveKey(key string) bool {
	keyLower := strings.ToLower(key)
	for _, pattern := range sensitiveKeyPatterns {
		if strings.Contains(keyLower, pattern) {
			return true
		}
	}
	return false
}

// isMaskedValue checks if a value appears to be a masked value (contains ****)
func isMaskedValue(value string) bool {
	return strings.Contains(value, maskedPlaceholder)
}

// SettingsService provides CRUD operations for system settings stored in the database.
// It also handles merging database settings with bootstrap configuration.
type SettingsService struct {
	store store.SettingsStore
	db    *gorm.DB // kept for transaction support
	mu    sync.RWMutex
}

// NewSettingsService creates a new settings service
func NewSettingsService(s store.Store) *SettingsService {
	return &SettingsService{
		store: s.Settings(),
		db:    s.DB(),
	}
}

// Get retrieves a single setting by category and key
func (s *SettingsService) Get(category, key string) (*model.SystemSetting, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	return s.store.Get(category, key)
}

// GetByCategory retrieves all settings for a category
func (s *SettingsService) GetByCategory(category string) ([]model.SystemSetting, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	return s.store.GetByCategory(category)
}

// GetAll retrieves all settings grouped by category
func (s *SettingsService) GetAll() (map[string][]model.SystemSetting, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	settings, err := s.store.GetAll()
	if err != nil {
		return nil, err
	}

	// Group by category
	result := make(map[string][]model.SystemSetting)
	for _, setting := range settings {
		result[setting.Category] = append(result[setting.Category], setting)
	}

	// For review category, ensure output_metadata has default values
	reviewCategory := string(model.SettingCategoryReview)
	if reviewSettings, ok := result[reviewCategory]; ok {
		for i, setting := range reviewSettings {
			if setting.Key == "output_metadata" {
				var meta OutputMetadataConfig
				if err := json.Unmarshal([]byte(setting.Value), &meta); err == nil {
					// Apply default value if custom_text is empty
					if meta.CustomText == "" {
						meta.CustomText = defaultCustomText
						// Re-serialize with default value
						if metaJSON, err := json.Marshal(meta); err == nil {
							result[reviewCategory][i].Value = string(metaJSON)
						}
					}
				}
			}
		}
	}

	return result, nil
}

// Set creates or updates a setting
func (s *SettingsService) Set(category, key, value string, valueType model.SettingValueType, username string) error {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.db.Transaction(func(tx *gorm.DB) error {
		txStore := s.store.WithTx(tx)

		// Check if setting exists
		existing, err := txStore.Get(category, key)

		if err == nil {
			// Update existing
			existing.Value = value
			existing.ValueType = string(valueType)
			if err := txStore.Save(existing); err != nil {
				return err
			}
		} else if err == gorm.ErrRecordNotFound {
			// Create new
			setting := &model.SystemSetting{
				Category:  category,
				Key:       key,
				Value:     value,
				ValueType: string(valueType),
			}
			if err := txStore.Create(setting); err != nil {
				return err
			}
		} else {
			return err
		}

		return nil
	})
}

// SetCategory sets all settings for a category at once (replacing existing)
// If a sensitive value contains the masked placeholder (****), the original value is preserved
func (s *SettingsService) SetCategory(category string, settings map[string]interface{}, username string) error {
	s.mu.Lock()
	defer s.mu.Unlock()

	// If db is nil (e.g., in tests with mock store), execute without transaction
	if s.db == nil {
		return s.setCategoryWithoutTx(category, settings, username)
	}

	return s.db.Transaction(func(tx *gorm.DB) error {
		txStore := s.store.WithTx(tx)

		// Get existing settings for comparison and for restoring masked values
		existing, _ := txStore.GetByCategory(category)
		existingMap := make(map[string]model.SystemSetting)
		for _, setting := range existing {
			existingMap[setting.Key] = setting
		}

		// Process each setting
		for key, value := range settings {
			// Restore masked sensitive values from existing settings
			value = restoreMaskedValues(key, value, existingMap)

			jsonValue, valueType, err := marshalSettingValue(value)
			if err != nil {
				logger.Error("Failed to marshal setting value",
					zap.String("category", category),
					zap.String("key", key),
					zap.Error(err))
				continue
			}

			if old, exists := existingMap[key]; exists {
				// Skip if value unchanged
				if old.Value == jsonValue {
					delete(existingMap, key)
					continue
				}

				// Update existing
				old.Value = jsonValue
				old.ValueType = string(valueType)
				if err := txStore.Save(&old); err != nil {
					return err
				}
				delete(existingMap, key)
			} else {
				// Check if soft-deleted record exists (to avoid UNIQUE constraint violation)
				var softDeleted model.SystemSetting
				err := tx.Unscoped().Where("category = ? AND key = ?", category, key).First(&softDeleted).Error
				if err == nil {
					// Restore and update soft-deleted record
					softDeleted.Value = jsonValue
					softDeleted.ValueType = string(valueType)
					softDeleted.DeletedAt = gorm.DeletedAt{}
					if err := tx.Unscoped().Save(&softDeleted).Error; err != nil {
						return err
					}
				} else {
					// Create new
					setting := &model.SystemSetting{
						Category:  category,
						Key:       key,
						Value:     jsonValue,
						ValueType: string(valueType),
					}
					if err := txStore.Create(setting); err != nil {
						return err
					}
				}
			}
		}

		// Delete settings that are no longer present
		for _, old := range existingMap {
			if err := txStore.DeleteSetting(&old); err != nil {
				return err
			}
		}

		return nil
	})
}

// setCategoryWithoutTx sets all settings for a category without using a transaction
// This is used when db is nil (e.g., in tests with mock store)
func (s *SettingsService) setCategoryWithoutTx(category string, settings map[string]interface{}, username string) error {
	// Get existing settings for comparison and for restoring masked values
	existing, _ := s.store.GetByCategory(category)
	existingMap := make(map[string]model.SystemSetting)
	for _, setting := range existing {
		existingMap[setting.Key] = setting
	}

	// Process each setting
	for key, value := range settings {
		// Restore masked sensitive values from existing settings
		value = restoreMaskedValues(key, value, existingMap)

		jsonValue, valueType, err := marshalSettingValue(value)
		if err != nil {
			logger.Error("Failed to marshal setting value",
				zap.String("category", category),
				zap.String("key", key),
				zap.Error(err))
			continue
		}

		if old, exists := existingMap[key]; exists {
			// Skip if value unchanged
			if old.Value == jsonValue {
				delete(existingMap, key)
				continue
			}

			// Update existing
			old.Value = jsonValue
			old.ValueType = string(valueType)
			if err := s.store.Save(&old); err != nil {
				return err
			}
			delete(existingMap, key)
		} else {
			// Check if soft-deleted record exists (to avoid UNIQUE constraint violation)
			// Only check if db is available (not in mock store tests)
			if s.db != nil {
				var softDeleted model.SystemSetting
				err := s.db.Unscoped().Where("category = ? AND key = ?", category, key).First(&softDeleted).Error
				if err == nil {
					// Restore and update soft-deleted record
					softDeleted.Value = jsonValue
					softDeleted.ValueType = string(valueType)
					softDeleted.DeletedAt = gorm.DeletedAt{}
					if err := s.db.Unscoped().Save(&softDeleted).Error; err != nil {
						return err
					}
				} else {
					// Create new
					setting := &model.SystemSetting{
						Category:  category,
						Key:       key,
						Value:     jsonValue,
						ValueType: string(valueType),
					}
					if err := s.store.Create(setting); err != nil {
						return err
					}
				}
			} else {
				// Create new (when db is nil, e.g., in tests with mock store)
				setting := &model.SystemSetting{
					Category:  category,
					Key:       key,
					Value:     jsonValue,
					ValueType: string(valueType),
				}
				if err := s.store.Create(setting); err != nil {
					return err
				}
			}
		}
	}

	// Delete settings that are no longer present
	for _, old := range existingMap {
		if err := s.store.DeleteSetting(&old); err != nil {
			return err
		}
	}

	return nil
}

// restoreMaskedValues recursively restores masked sensitive values from existing settings
func restoreMaskedValues(key string, value interface{}, existingMap map[string]model.SystemSetting) interface{} {
	switch v := value.(type) {
	case string:
		// If this is a sensitive key and the value is masked, restore original
		if isSensitiveKey(key) && isMaskedValue(v) {
			if old, exists := existingMap[key]; exists {
				// Parse the old value
				var oldVal string
				if err := json.Unmarshal([]byte(old.Value), &oldVal); err == nil {
					logger.Debug("Restored masked sensitive value",
						zap.String("key", key))
					return oldVal
				}
			}
		}
		return v

	case map[string]interface{}:
		// For nested objects (like agent configs), check each field
		result := make(map[string]interface{})
		for k, val := range v {
			// For nested objects, we need to check against the stored JSON
			if strVal, ok := val.(string); ok && isSensitiveKey(k) && isMaskedValue(strVal) {
				// Try to get original value from the parent key's stored object
				if old, exists := existingMap[key]; exists {
					var oldObj map[string]interface{}
					if err := json.Unmarshal([]byte(old.Value), &oldObj); err == nil {
						if originalVal, ok := oldObj[k]; ok {
							result[k] = originalVal
							logger.Debug("Restored nested masked sensitive value",
								zap.String("parent_key", key),
								zap.String("key", k))
							continue
						}
					}
				}
			}
			result[k] = val
		}
		return result

	case []interface{}:
		// For arrays (like providers), process each item
		result := make([]interface{}, len(v))
		for i, item := range v {
			if obj, ok := item.(map[string]interface{}); ok {
				// Get the old array value if exists
				var oldArray []interface{}
				if old, exists := existingMap[key]; exists {
					json.Unmarshal([]byte(old.Value), &oldArray)
				}

				// Process each field in the object
				newObj := make(map[string]interface{})
				for k, val := range obj {
					if strVal, ok := val.(string); ok && isSensitiveKey(k) && isMaskedValue(strVal) {
						// Try to find matching item in old array and restore value
						if i < len(oldArray) {
							if oldItem, ok := oldArray[i].(map[string]interface{}); ok {
								if originalVal, ok := oldItem[k]; ok {
									newObj[k] = originalVal
									logger.Debug("Restored array item masked sensitive value",
										zap.String("key", key),
										zap.Int("index", i),
										zap.String("field", k))
									continue
								}
							}
						}
					}
					newObj[k] = val
				}
				result[i] = newObj
			} else {
				result[i] = item
			}
		}
		return result

	default:
		return v
	}
}

// Delete removes a setting
func (s *SettingsService) Delete(category, key, username string) error {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.db.Transaction(func(tx *gorm.DB) error {
		txStore := s.store.WithTx(tx)

		setting, err := txStore.Get(category, key)
		if err != nil {
			return err
		}

		if err := txStore.DeleteSetting(setting); err != nil {
			return err
		}

		return nil
	})
}

// HasSettings checks if any settings exist in the database
func (s *SettingsService) HasSettings() (bool, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	count, err := s.store.Count()
	if err != nil {
		return false, err
	}
	return count > 0, nil
}

// marshalSettingValue converts a Go value to JSON string and determines its type
func marshalSettingValue(value interface{}) (string, model.SettingValueType, error) {
	var valueType model.SettingValueType

	switch value.(type) {
	case string:
		valueType = model.SettingValueTypeString
	case bool:
		valueType = model.SettingValueTypeBoolean
	case int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, float32, float64:
		valueType = model.SettingValueTypeNumber
	case []interface{}:
		valueType = model.SettingValueTypeArray
	case map[string]interface{}:
		valueType = model.SettingValueTypeObject
	default:
		// Use reflection to determine the actual type for structs, slices, etc.
		rv := reflect.ValueOf(value)
		kind := rv.Kind()
		if kind == reflect.Ptr {
			if rv.IsNil() {
				valueType = model.SettingValueTypeObject
			} else {
				kind = rv.Elem().Kind()
			}
		}
		switch kind {
		case reflect.Struct:
			valueType = model.SettingValueTypeObject
		case reflect.Slice, reflect.Array:
			valueType = model.SettingValueTypeArray
		case reflect.Map:
			valueType = model.SettingValueTypeObject
		default:
			valueType = model.SettingValueTypeString
		}
	}

	// Directly JSON marshal the original value (not fmt.Sprintf)
	jsonBytes, err := json.Marshal(value)
	if err != nil {
		return "", "", err
	}
	return string(jsonBytes), valueType, nil
}

// isValidCategory checks if a category is valid
func isValidCategory(category string) bool {
	validCategories := model.AllSettingCategories()
	for _, c := range validCategories {
		if string(c) == category {
			return true
		}
	}
	return false
}

// isMalformedStructString checks if a string value looks like a Go struct string representation
// e.g., "{cursor-agent key_xxx 600 composer-1 [sonnet-4.5 composer-1]}"
func isMalformedStructString(value string) bool {
	// Check if it's a JSON string containing a Go struct representation
	// These look like: "{field1 field2 field3}" with spaces between fields
	if len(value) < 4 {
		return false
	}

	// Unescape JSON string first
	var unescaped string
	if err := json.Unmarshal([]byte(value), &unescaped); err != nil {
		return false
	}

	// Check if it starts with { and ends with }
	if !strings.HasPrefix(unescaped, "{") || !strings.HasSuffix(unescaped, "}") {
		return false
	}

	// Try to parse as JSON - if it fails, it's likely a malformed struct string
	var jsonTest interface{}
	if err := json.Unmarshal([]byte(unescaped), &jsonTest); err != nil {
		// Not valid JSON, so it's likely a Go struct string representation
		return true
	}

	return false
}

// RepairMalformedSettings detects and removes malformed setting values
// that were incorrectly stored as Go struct string representations
func (s *SettingsService) RepairMalformedSettings() (int, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	settings, err := s.store.GetAll()
	if err != nil {
		return 0, fmt.Errorf("failed to query settings: %w", err)
	}

	var malformedKeys []string
	for _, setting := range settings {
		// Check for malformed string values that should be objects
		if setting.ValueType == string(model.SettingValueTypeString) {
			if isMalformedStructString(setting.Value) {
				malformedKeys = append(malformedKeys, fmt.Sprintf("%s.%s", setting.Category, setting.Key))
			}
		}
	}

	if len(malformedKeys) == 0 {
		return 0, nil
	}

	// Delete malformed records so they can be recreated with correct format
	deleted := 0
	err = s.db.Transaction(func(tx *gorm.DB) error {
		txStore := s.store.WithTx(tx)
		for _, setting := range settings {
			if setting.ValueType == string(model.SettingValueTypeString) {
				if isMalformedStructString(setting.Value) {
					if err := txStore.DeleteSetting(&setting); err != nil {
						return fmt.Errorf("failed to delete malformed setting %s.%s: %w",
							setting.Category, setting.Key, err)
					}
					deleted++
					logger.Info("Deleted malformed setting",
						zap.String("category", setting.Category),
						zap.String("key", setting.Key),
						zap.String("old_value", setting.Value))
				}
			}
		}
		return nil
	})

	if err != nil {
		return 0, err
	}

	return deleted, nil
}

// GetGitProviders retrieves Git providers configuration from database.
// This method directly reads from database to ensure the latest configuration is used.
// Returns empty slice if no providers are configured.
func (s *SettingsService) GetGitProviders() ([]ProviderConfig, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	setting, err := s.store.Get(string(model.SettingCategoryGit), "providers")
	if err != nil {
		// If not found, return empty slice (not an error)
		if err == gorm.ErrRecordNotFound {
			return []ProviderConfig{}, nil
		}
		return nil, fmt.Errorf("failed to get git providers: %w", err)
	}

	if setting == nil || setting.Value == "" {
		return []ProviderConfig{}, nil
	}

	var providers []ProviderConfig
	if err := json.Unmarshal([]byte(setting.Value), &providers); err != nil {
		return nil, fmt.Errorf("failed to parse git providers: %w", err)
	}

	return providers, nil
}

// GetAgentConfig retrieves agent configuration from database.
// Returns nil if the agent is not configured.
func GetAgentConfig(s store.Store, agentName string) (*AgentDetail, error) {
	if s == nil {
		return nil, nil
	}

	svc := NewSettingsService(s)
	setting, err := svc.Get(string(model.SettingCategoryAgents), agentName)
	if err != nil {
		return nil, err
	}
	if setting == nil {
		return nil, nil
	}

	var agent AgentDetail
	if err := json.Unmarshal([]byte(setting.Value), &agent); err != nil {
		return nil, fmt.Errorf("failed to parse agent config: %w", err)
	}

	return &agent, nil
}

// GetReviewConfig retrieves review configuration from database.
// This method directly reads from database to ensure the latest configuration is used.
// Returns default values if no configuration is found.
func (s *SettingsService) GetReviewConfig() (*ReviewConfig, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	settings, err := s.store.GetByCategory(string(model.SettingCategoryReview))
	if err != nil {
		return nil, fmt.Errorf("failed to get review config: %w", err)
	}

	// Build config from individual settings with defaults
	trueVal := true
	cfg := &ReviewConfig{
		MaxConcurrent:  3,  // default
		RetentionDays:  30, // default
		MaxRetries:     3,  // default
		RetryDelay:     10, // default
		OutputLanguage: "en",
		OutputMetadata: OutputMetadataConfig{
			ShowAgent:  &trueVal,
			ShowModel:  &trueVal,
			CustomText: defaultCustomText,
		},
	}

	for _, setting := range settings {
		switch setting.Key {
		case "workspace":
			cfg.Workspace = parseStringValue(setting.Value)
		case "max_concurrent":
			cfg.MaxConcurrent = parseIntValue(setting.Value, 3)
		case "retention_days":
			cfg.RetentionDays = parseIntValue(setting.Value, 30)
		case "max_retries":
			cfg.MaxRetries = parseIntValue(setting.Value, 3)
		case "retry_delay":
			cfg.RetryDelay = parseIntValue(setting.Value, 10)
		case "output_language":
			cfg.OutputLanguage = parseStringValue(setting.Value)
		case "output_metadata":
			var meta OutputMetadataConfig
			if err := json.Unmarshal([]byte(setting.Value), &meta); err == nil {
				cfg.OutputMetadata = meta
				// Ensure custom_text has default value if empty
				if cfg.OutputMetadata.CustomText == "" {
					cfg.OutputMetadata.CustomText = defaultCustomText
				}
			}
		}
	}

	return cfg, nil
}

// GetReportConfig retrieves report configuration from database.
// This method directly reads from database to ensure the latest configuration is used.
// Returns default values if no configuration is found.
func (s *SettingsService) GetReportConfig() (*ReportConfig, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	settings, err := s.store.GetByCategory(string(model.SettingCategoryReport))
	if err != nil {
		return nil, fmt.Errorf("failed to get report config: %w", err)
	}

	// Build config from individual settings
	cfg := &ReportConfig{
		Workspace:      "report_workspace",
		MaxConcurrent:  2,  // default
		MaxRetries:     3,  // default
		RetryDelay:     10, // default
		OutputLanguage: "en",
	}

	for _, setting := range settings {
		switch setting.Key {
		case "workspace":
			cfg.Workspace = parseStringValue(setting.Value)
		case "max_concurrent":
			cfg.MaxConcurrent = parseIntValue(setting.Value, 2)
		case "max_retries":
			cfg.MaxRetries = parseIntValue(setting.Value, 3)
		case "retry_delay":
			cfg.RetryDelay = parseIntValue(setting.Value, 10)
		case "output_language":
			cfg.OutputLanguage = parseStringValue(setting.Value)
		}
	}

	return cfg, nil
}

// GetNotificationConfig retrieves notification configuration from database.
// This method directly reads from database to ensure the latest configuration is used.
// Returns nil (disabled) if no configuration is found.
func (s *SettingsService) GetNotificationConfig() (*NotificationConfig, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	settings, err := s.store.GetByCategory(string(model.SettingCategoryNotifications))
	if err != nil {
		return nil, fmt.Errorf("failed to get notification config: %w", err)
	}

	if len(settings) == 0 {
		return nil, nil // notifications disabled
	}

	cfg := &NotificationConfig{}

	for _, setting := range settings {
		switch setting.Key {
		case "channel":
			cfg.Channel = NotificationChannel(parseStringValue(setting.Value))
		case "events":
			var events []NotificationEvent
			if err := json.Unmarshal([]byte(setting.Value), &events); err == nil {
				cfg.Events = events
			}
		case "webhook":
			var webhook WebhookNotificationConfig
			if err := json.Unmarshal([]byte(setting.Value), &webhook); err == nil {
				cfg.Webhook = webhook
			}
		case "email":
			var email EmailNotificationConfig
			if err := json.Unmarshal([]byte(setting.Value), &email); err == nil {
				cfg.Email = email
			}
		case "slack":
			var slack SlackNotificationConfig
			if err := json.Unmarshal([]byte(setting.Value), &slack); err == nil {
				cfg.Slack = slack
			}
		case "feishu":
			var feishu FeishuNotificationConfig
			if err := json.Unmarshal([]byte(setting.Value), &feishu); err == nil {
				cfg.Feishu = feishu
			}
		}
	}

	return cfg, nil
}

// GetAgents retrieves all agent configurations from database.
// This method directly reads from database to ensure the latest configuration is used.
func (s *SettingsService) GetAgents() (map[string]AgentDetail, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	settings, err := s.store.GetByCategory(string(model.SettingCategoryAgents))
	if err != nil {
		return nil, fmt.Errorf("failed to get agents config: %w", err)
	}

	agents := make(map[string]AgentDetail)
	for _, setting := range settings {
		var agent AgentDetail
		if err := json.Unmarshal([]byte(setting.Value), &agent); err != nil {
			continue
		}
		agents[setting.Key] = agent
	}

	return agents, nil
}

// parseStringValue parses a JSON-encoded string value
func parseStringValue(jsonValue string) string {
	var s string
	if err := json.Unmarshal([]byte(jsonValue), &s); err != nil {
		// If not a JSON string, return as-is
		return jsonValue
	}
	return s
}

// parseIntValue parses a JSON-encoded int value with a default fallback
func parseIntValue(jsonValue string, defaultVal int) int {
	var i int
	if err := json.Unmarshal([]byte(jsonValue), &i); err != nil {
		return defaultVal
	}
	return i
}
